#! /usr/bin/env python

import asyncio
import datetime
import html
import http.client
import json
import pathlib
import re
import subprocess
import sys


def make_request(host, path):
    connection = http.client.HTTPSConnection(host)
    connection.request("GET", path, headers={"host": host})
    response = connection.getresponse()
    data = response.read().decode()
    connection.close()
    return response.status, data


class Block:
    def __init__(self, interval: int = 30) -> None:
        self.interval = interval
        self.data = {}

    async def update(self):
        """Override this method in subclasses for specific behavior."""
        pass

    async def run(self):
        """Runs the update method periodically forever."""
        while True:
            await self.update()
            await asyncio.sleep(self.interval)

    def set_data(self, title: str, value: str, value_gray=False) -> None:
        text = f"<b><span font_stretch='ultraexpanded' foreground='#046E8F'>{title}</span></b> "
        text += f"<span foreground='#91A3B0'>{value}</span>" if value_gray else f"{value}"
        full_text= text
        short_text= text
        self.data = {"full_text": full_text, "short_text": short_text, "markup": "pango"}


class DateBlock(Block):
    async def update(self) -> None:
        value = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
        self.set_data("DATE", value)

class NetworkBlock(Block):
    def __init__(self, interface: str, interval: int = 30):
        self.interface = interface
        super().__init__(interval)

    async def update(self):
        process = subprocess.run("nmcli c show --active".split(), capture_output=True)
        for net in process.stdout.decode().split("\n")[1:]:
            if net and net.split()[3].upper() == self.interface.upper():
                self.set_data(net.split()[3].upper(), net.split()[0])
                break
        else:
            self.data = {}


class BatteryBlock(Block):
    async def update(self) -> None:
        with open("/sys/class/power_supply/BAT0/energy_full", "r") as f:
            battery_full = int(f.read().strip())

        with open("/sys/class/power_supply/BAT0/energy_now", "r") as f:
            battery_now = int(f.read().strip())

        with open("/sys/class/power_supply/BAT0/status", "r") as f:
            battery_status = f.read().strip()

        power = int(battery_now * 100 / battery_full)
        status = ""
        if battery_status == "Charging":
            status = "+"

        self.set_data("BAT", f"{status}{power}%")


class CpuBlock(Block):
    async def update(self) -> None:
        process = subprocess.run("vmstat 1 2".split(), capture_output=True)
        value = 100 - int(process.stdout.decode().split("\n")[3].split()[14])
        self.set_data("CPU", f"{value}%")


class MemoryBlock(Block):
    async def update(self) -> None:
        process = subprocess.run("free".split(), capture_output=True)
        line = process.stdout.decode().split("\n")[1].split()
        value = int(int(line[2]) * 100 / int(line[1]))
        self.set_data("MEM", f"{value}%")


class DiskBlock(Block):
    async def update(self) -> None:
        process = subprocess.run("df".split(), capture_output=True)
        lines = process.stdout.decode().split("\n")[1:]
        for line in lines:
            if line.split()[-1] == "/":
                value = line.split()[-2]
                self.set_data("DISK", f"{value}")
                break


class VolumeBlock(Block):
    async def update(self) -> None:
        process = subprocess.run("pactl get-sink-mute @DEFAULT_SINK@".split(), capture_output=True)
        if process.stdout.decode().split()[-1] == "yes":
            self.set_data("VOL", f"-", value_gray=True)
            return

        process = subprocess.run("pactl get-sink-volume @DEFAULT_SINK@".split(), capture_output=True)
        try:
            value = max([int(x.replace("%", "")) for x in process.stdout.decode().split("\n")[0].split()[4:12:7]])
            self.set_data("VOL", f"{value}%")
        except:
            pass


class CpuTempBlock(Block):
    async def update(self) -> None:
        p = pathlib.Path("/sys/devices/platform/coretemp.0/hwmon") 
        value = int(int(list(p.walk())[1][0].joinpath("temp1_input").open().read().strip()) / 1000)
        self.set_data("TEMP", f"{value}Â°C")


class WeatherBlock(Block):
    async def update(self) -> None:
        host = "www.buienalarm.nl"
        path = "/nederland/amsterdam/5576"
        loop = asyncio.get_running_loop()
        status, data = await loop.run_in_executor(None, make_request, host, path)
        temp = re.findall("<span class=\"text-secondary font-semibold text-6xl inline-block\">([^<]+)</span>", data)[0]
        temp = html.unescape(temp)
        rain = re.findall("<span class=\"text-md\">([^<]+)</span>", data)[1]
        self.set_data("AMS", f"{temp}C {rain}mm".replace(",", "."))


class Writer:
    def print_line(self, txt: str):
        self._print(txt)

    def print_text(self, txt: str):
        self._print(txt, end="")

    def _print(self, txt: str, end="\n") -> None:
        sys.stdout.write(txt + end)
        sys.stdout.flush()


class Bar:
    def __init__(self, writer: Writer) -> None:
        self.writer = writer
        self.block_list = []
        self.headers = {"version": 1}

    def add_block(self, block: Block) -> None:
        self.block_list.append(block)

    def start(self):
        self.writer.print_line(json.dumps(self.headers))
        self.writer.print_line("[")

    async def update(self):
        while True:
            block_update_list = []
            for block in self.block_list:
                if block.data:
                    block_update_list.insert(0, block.data)

            self.writer.print_line(json.dumps(block_update_list) + ",")
            await asyncio.sleep(1)


async def main():
    w = Writer()
    bar = Bar(w)
    bar.add_block(DateBlock(1))
    bar.add_block(NetworkBlock("wlan0", 5))
    bar.add_block(BatteryBlock(3))
    bar.add_block(CpuBlock(5))
    bar.add_block(MemoryBlock(5))
    bar.add_block(DiskBlock(5))
    bar.add_block(VolumeBlock(5))
    bar.add_block(CpuTempBlock(5))
    bar.add_block(WeatherBlock(300))

    bar.start()
    tasks = [asyncio.create_task(obj.run()) for obj in bar.block_list]
    await asyncio.gather(*tasks, asyncio.create_task(bar.update()))


if __name__ == "__main__":
    asyncio.run(main())
